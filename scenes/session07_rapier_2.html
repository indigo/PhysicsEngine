<!DOCTYPE html>
<html>
<head>
    <title>Bloc 3: Rapier.js - Démo Pendule (RevoluteJoint 3D) - Corrigé</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "../three.js/build/three.module.js",
                "jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'jsm/controls/OrbitControls.js';

        let RAPIER;

        let camera, scene, renderer;
        let clock = new THREE.Clock();
        let controls;

        let groundMesh_three;
        let pendulumMesh_three;
        let pivotMesh_three;

        let world_rapier;
        let groundCollider_rapier;
        let pivotBody_rapier;
        let pendulumBody_rapier;

        let debugLines_three;
        const MAX_DEBUG_VERTICES = 10000;

        const simParams = {
            timeScale: 1.0,
            gravityY: -9.81,
            pendulumLength: 1.5, 
            pendulumBoxSize: 0.4, 
            pendulumMass: 1.0,
            pendulumRestitution: 0.3,
            pivotYPosition: 3.0,
            groundY: -2.0,
            groundSizeX: 15.0,
            groundSizeZ: 10.0,
            groundRestitution: 0.5,
            showRapierDebug: true,
            resetSimulation: function() { resetSimulation(); }
        };

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xEEEEff);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, simParams.pivotYPosition, 8);
            camera.lookAt(0, simParams.pivotYPosition - simParams.pendulumLength / 2, 0);

            const ambient = new THREE.HemisphereLight(0xffffff, 0x888888, 3.0);
            scene.add(ambient);
            const light = new THREE.DirectionalLight(0xfffefe, 3);
            light.position.set(1, 4, 8);
            light.castShadow = true;
            scene.add(light);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target = new THREE.Vector3(0, simParams.pivotYPosition - simParams.pendulumLength / 2, 0);


            try {
                const rapierModule = await import('https://cdn.skypack.dev/@dimforge/rapier3d-compat');
                RAPIER = rapierModule.default;
                // Correction pour l'avertissement de dépréciation
                await RAPIER.init({}); 
                console.log("Rapier.js 3D chargé et initialisé.");

                setupDatGUI();
                createPhysicsWorld_rapier();
                createVisuals_three();
                createDebugRenderer_three();
                resetPhysicsState();

                renderer.setAnimationLoop(animate);

            } catch (e) {
                console.error("Erreur lors du chargement ou de l'initialisation de Rapier.js:", e);
                document.body.innerHTML = "Impossible de charger la simulation physique. Erreur : " + e.message;
                return;
            }

            window.addEventListener('resize', onWindowResize, false);
            displayInstructions();
        }

        function displayInstructions(){
            console.log("--- Démo: Rapier.js - Pendule Simple (RevoluteJoint 3D) ---");
            console.log("Un cube pendule oscille à partir d'un point de pivot fixe.");
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createPhysicsWorld_rapier() {
            if (!RAPIER) return;
            if (world_rapier) world_rapier.free();

            let gravity = { x: 0.0, y: simParams.gravityY, z: 0.0 };
            world_rapier = new RAPIER.World(gravity);

            // ... (création groundCollider_rapier) ...
            let groundColliderDesc = RAPIER.ColliderDesc.cuboid(simParams.groundSizeX / 2, 0.1, simParams.groundSizeZ / 2)
                .setTranslation(0.0, simParams.groundY - 0.1, 0.0)
                .setRestitution(simParams.groundRestitution);
            groundCollider_rapier = world_rapier.createCollider(groundColliderDesc);


            // --- Création du Pivot Statique ---
            let pivotBodyDesc = RAPIER.RigidBodyDesc.fixed()
                .setTranslation(0.0, simParams.pivotYPosition, 0.0); // Position du pivot dans le monde
            pivotBody_rapier = world_rapier.createRigidBody(pivotBodyDesc);
            // Pas besoin de collider pour le pivot si c'est juste un point d'ancrage pour le joint

            // --- Création du Corps Dynamique du Pendule ---
            let pendulumBodyDesc = RAPIER.RigidBodyDesc.dynamic();
            pendulumBody_rapier = world_rapier.createRigidBody(pendulumBodyDesc);
            // La position initiale du pendule sera définie dans resetPhysicsState pour correspondre au joint

            let pendulumColliderDesc = RAPIER.ColliderDesc.cuboid(
                simParams.pendulumBoxSize, // demi-largeur (X)
                simParams.pendulumBoxSize, // demi-hauteur (Y)
                simParams.pendulumBoxSize  // demi-profondeur (Z)
            )
                .setRestitution(simParams.pendulumRestitution)
                .setMass(simParams.pendulumMass);
            world_rapier.createCollider(pendulumColliderDesc, pendulumBody_rapier);

            // --- Création du RevoluteJoint (selon l'exemple Rapier) ---
            let anchorOnParent = { x: 0.0, y: 0.0, z: 0.0 }; 
            let anchorOnChild = { x: 0.0, y: simParams.pendulumBoxSize+2, z: 0.0 }; 
            let rotationAxis = { x: 0.0, y: 0.0, z: 1.0 };
            let jointParams = RAPIER.JointData.revolute(anchorOnParent, anchorOnChild, rotationAxis);
            world_rapier.createImpulseJoint(jointParams, pivotBody_rapier, pendulumBody_rapier, true); 
        }
        function resetPhysicsState() {
            if (!pendulumBody_rapier || !pivotBody_rapier) return;

            const initialAngle = 0.3; 
            const pivotPos = pivotBody_rapier.translation();

            const pendulumX = pivotPos.x + simParams.pendulumLength * Math.sin(initialAngle);
            const pendulumY = pivotPos.y - simParams.pendulumLength * Math.cos(initialAngle);

            pendulumBody_rapier.setTranslation({ x: pendulumX, y: pendulumY, z: 0.0 }, true);
            
            // Correction pour la création du Quaternion :
            // La plupart des API de quaternion permettent de créer un quaternion à partir d'un angle et d'un axe.
            // S'il n'y a pas de méthode statique directe `fromAngleAxis` sur `RAPIER.UnitQuaternion` ou `RAPIER.Quaternion`,
            // on peut devoir passer par la création d'un objet quaternion puis l'initialiser,
            // ou utiliser une fonction utilitaire de la librairie Three.js pour créer le quaternion
            // et ensuite le convertir si nécessaire, bien que Rapier ait ses propres types.

            // Tentative 1: Vérifier si UnitQuaternion est un constructeur et a une méthode
            // Cela dépend fortement de l'API exacte de la version de Rapier que Skypack sert.
            // Une approche plus standard si `fromAngleAxis` n'est pas statique:
            let initialRotationQuat;
            const rotationAxisVec = new RAPIER.Vector3(0.0, 0.0, 1.0); // Axe Z

            // Méthode la plus courante si la classe existe :
            if (RAPIER.UnitQuaternion && typeof RAPIER.UnitQuaternion.rotationAroundAxis === 'function') {
                // Certaines versions plus anciennes ou différentes de Rapier pourraient avoir cela
                initialRotationQuat = RAPIER.UnitQuaternion.rotationAroundAxis(rotationAxisVec, initialAngle);
            } else if (RAPIER.Quaternion && typeof RAPIER.Quaternion.from_axis_angle === 'function') {
                // Une autre convention d'API possible
                initialRotationQuat = RAPIER.Quaternion.from_axis_angle(rotationAxisVec, initialAngle);
            }
            // Si ce qui précède ne fonctionne pas, il faut peut-être passer par un constructeur d'isométrie
            // ou utiliser Three.js pour créer le quaternion puis assigner ses composantes x,y,z,w
            // Mais essayons d'abord de trouver la méthode Rapier.

            // Alternative : On sait que Rapier utilise des quaternions pour la rotation.
            // Une méthode courante pour définir la rotation d'un corps rigide est de lui donner directement
            // les composantes du quaternion.
            // Si fromAngleAxis n'est pas là, créons le quaternion manuellement
            // à partir des formules standards (ou utilisons Three.js pour le faire).

            // Utilisation de THREE.js pour créer le quaternion puis l'appliquer :
            // C'est une solution de contournement si les méthodes directes de Rapier.Quaternion ne sont pas claires.
            const threeQuaternion = new THREE.Quaternion();
            const threeAxis = new THREE.Vector3(0, 0, 1);
            threeQuaternion.setFromAxisAngle(threeAxis, initialAngle);

            // Appliquer à Rapier (Rapier attend un objet avec x,y,z,w ou un UnitQuaternion)
            initialRotationQuat = { 
                x: threeQuaternion.x, 
                y: threeQuaternion.y, 
                z: threeQuaternion.z, 
                w: threeQuaternion.w 
            };
            // Ou si Rapier.UnitQuaternion est un constructeur qui prend x,y,z,w:
            // initialRotationQuat = new RAPIER.UnitQuaternion(threeQuaternion.x, threeQuaternion.y, threeQuaternion.z, threeQuaternion.w);

            if (initialRotationQuat) {
                pendulumBody_rapier.setRotation(initialRotationQuat, true);
            } else {
                console.error("Impossible de créer le quaternion de rotation initial pour le pendule.");
                // Par défaut, pas de rotation initiale si la méthode échoue
                pendulumBody_rapier.setRotation({x:0,y:0,z:0,w:1}, true); 
            }


            pendulumBody_rapier.setLinvel({ x: 0.0, y: 0.0, z: 0.0 }, true);
            pendulumBody_rapier.setAngvel({ x: 0.0, y: 0.0, z: 0.0 }, true);
            pendulumBody_rapier.wakeUp();

            // ... (reste de la fonction resetPhysicsState)
            const pendulumCollider = pendulumBody_rapier.collider(0);
            if (pendulumCollider) {
                pendulumCollider.setRestitution(simParams.pendulumRestitution);
                pendulumCollider.setMass(simParams.pendulumMass);
            }
            
            if (groundCollider_rapier) {
                groundCollider_rapier.setRestitution(simParams.groundRestitution);
            }
            if (world_rapier) { 
                world_rapier.gravity.y = simParams.gravityY;
            }

            if (pendulumMesh_three && pendulumBody_rapier) {
                const initialPosRapier = pendulumBody_rapier.translation();
                const initialRotRapier = pendulumBody_rapier.rotation();
                pendulumMesh_three.position.set(initialPosRapier.x, initialPosRapier.y, initialPosRapier.z);
                pendulumMesh_three.quaternion.set(initialRotRapier.x, initialRotRapier.y, initialRotRapier.z, initialRotRapier.w);
            }
            if (pivotMesh_three && pivotBody_rapier){
                const pivotPosRapier = pivotBody_rapier.translation();
                pivotMesh_three.position.set(pivotPosRapier.x, pivotPosRapier.y, pivotPosRapier.z);
            }

            if (debugLines_three) {
                const positions = debugLines_three.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i++) positions[i] = 0;
                debugLines_three.geometry.setDrawRange(0, 0);
                debugLines_three.geometry.attributes.position.needsUpdate = true;
            }
        }
       
        function createVisuals_three() {
            if (groundMesh_three) scene.remove(groundMesh_three);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x99aa77, metalness:0.2, roughness:0.8 });
            const floorGeometry = new THREE.PlaneGeometry(simParams.groundSizeX, simParams.groundSizeZ);
            groundMesh_three = new THREE.Mesh(floorGeometry, floorMaterial);
            groundMesh_three.rotation.x = -Math.PI / 2;
            groundMesh_three.position.y = simParams.groundY;
            groundMesh_three.receiveShadow = true;
            scene.add(groundMesh_three);

            if (pivotMesh_three) scene.remove(pivotMesh_three);
            const pivotGeom = new THREE.SphereGeometry(0.1, 16, 8);
            const pivotMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness:0.8, roughness:0.3 });
            pivotMesh_three = new THREE.Mesh(pivotGeom, pivotMat);
            pivotMesh_three.castShadow = true;
            scene.add(pivotMesh_three); // Sa position sera mise à jour dans resetPhysicsState

            if (pendulumMesh_three) scene.remove(pendulumMesh_three);
            const geom = new THREE.BoxGeometry(
                simParams.pendulumBoxSize * 2, 
                simParams.pendulumBoxSize * 2, 
                simParams.pendulumBoxSize * 2
            );
            const mat = new THREE.MeshStandardMaterial({ color: 0x0077ff, metalness:0.4, roughness:0.6 });
            pendulumMesh_three = new THREE.Mesh(geom, mat);
            pendulumMesh_three.castShadow = true;
            scene.add(pendulumMesh_three);
        }

        function createDebugRenderer_three() {
            if (debugLines_three) {
                scene.remove(debugLines_three);
                debugLines_three.geometry.dispose();
                debugLines_three.material.dispose();
            }
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: true });
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(MAX_DEBUG_VERTICES * 3);
            const colors = new Float32Array(MAX_DEBUG_VERTICES * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
            debugLines_three = new THREE.LineSegments(geometry, material);
            debugLines_three.frustumCulled = false; 
            scene.add(debugLines_three);
        }

        function updateDebugRenderer_three() {
             if (!world_rapier || !debugLines_three || !simParams.showRapierDebug) {
                if (debugLines_three) debugLines_three.visible = false;
                return;
            }
            debugLines_three.visible = true;
            const buffers = world_rapier.debugRender(); 
            const vertices = buffers.vertices;
            const colorsRapier = buffers.colors; 
            const positionsAttribute = debugLines_three.geometry.attributes.position;
            const colorsAttribute = debugLines_three.geometry.attributes.color;
            let vertexCount = Math.min(MAX_DEBUG_VERTICES, vertices.length / 3); 
            for (let i = 0; i < vertexCount; i++) {
                positionsAttribute.setXYZ(i, vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
                colorsAttribute.setXYZ(i, colorsRapier[i * 4], colorsRapier[i * 4 + 1], colorsRapier[i * 4 + 2]);
            }
            positionsAttribute.needsUpdate = true;
            colorsAttribute.needsUpdate = true;
            debugLines_three.geometry.setDrawRange(0, vertexCount);
        }

        function resetSimulation() {
            createPhysicsWorld_rapier();
            createVisuals_three();
            if (!debugLines_three && RAPIER) createDebugRenderer_three();
            resetPhysicsState();
            clock.start();
            console.log("Simulation Pendule Réinitialisée.");
        }

        function animate() {
            if (world_rapier) {
                world_rapier.step();
                
                if (pendulumBody_rapier && pendulumMesh_three) {
                    let position_rapier = pendulumBody_rapier.translation();
                    let rotation_rapier = pendulumBody_rapier.rotation();
                    pendulumMesh_three.position.set(position_rapier.x, position_rapier.y, position_rapier.z);
                    pendulumMesh_three.quaternion.set(rotation_rapier.x, rotation_rapier.y, rotation_rapier.z, rotation_rapier.w);
                }
                if (pivotBody_rapier && pivotMesh_three) { // Mise à jour du pivot visuel
                    let pivot_pos_rapier = pivotBody_rapier.translation();
                    pivotMesh_three.position.set(pivot_pos_rapier.x, pivot_pos_rapier.y, pivot_pos_rapier.z);
                }
                updateDebugRenderer_three();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function setupDatGUI() {
            const gui = new dat.GUI();
            gui.add(simParams, 'resetSimulation').name("Réinitialiser Simulation");
            gui.add(simParams, 'timeScale', 0.1, 2.0, 0.05).name('Échelle de Temps');
            gui.add(simParams, 'showRapierDebug').name("Afficher Debug Rapier").onChange(updateDebugRenderer_three);

            const physicsFolder = gui.addFolder('Physique Pendule');
            physicsFolder.add(simParams, 'gravityY', -20.0, 0.0, 0.1).name('Gravité Y').onChange(resetSimulation);
            physicsFolder.add(simParams, 'pendulumMass', 0.1, 5.0, 0.1).name('Masse Pendule').onChange(resetSimulation);
            physicsFolder.add(simParams, 'pendulumRestitution', 0.0, 1.0, 0.01).name('Restitution Pendule').onChange(resetSimulation);
            physicsFolder.add(simParams, 'pendulumLength', 0.5, 3.0, 0.1).name('Longueur "Corde"').onChange(resetSimulation);
            physicsFolder.add(simParams, 'pendulumBoxSize', 0.1, 0.5, 0.01).name('Taille Boîte Pendule').onChange(resetSimulation);
            physicsFolder.open();

            const sceneSetupFolder = gui.addFolder('Configuration Scène');
            sceneSetupFolder.add(simParams, 'pivotYPosition', simParams.groundY + 0.5, 5.0, 0.1).name('Hauteur Pivot').onChange(resetSimulation);
            sceneSetupFolder.add(simParams, 'groundRestitution', 0.0, 1.0, 0.01).name('Restitution Sol').onChange(resetSimulation);
            sceneSetupFolder.open();
        }

        init().catch(error => {
            console.error("Erreur fatale lors de l'initialisation:", error);
            document.body.innerHTML = "Impossible de charger la simulation. Vérifiez la console.";
        });

    </script>
</body>
</html>