<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Titre et métadonnées -->
    <title>Ammo.js - Cube Souple</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    
    <!-- Styles CSS -->
    <style>
        /* Style de base */
        body { margin: 0; color: #fff; background-color: #000; }
        /* Barre d'information en haut */
        #info { position: absolute; top: 10px; width: 100%; text-align: center; }
        /* Style des liens */
        a { color: #0af; }
    </style>
</head>
<body>
    <!-- Barre d'information -->
    <div id="info">Ammo.js - Cube Souple</div>
    <!-- Conteneur pour Three.js -->
    <div id="container"></div>

    <!-- Bibliothèque Ammo.js (pour la physique) -->
    <script src="https://threejs.org/examples/jsm/libs/ammo.wasm.js"></script>

    <!-- Configuration des imports pour Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Import des bibliothèques nécessaires
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // Déclaration des variables principales
        // Les variables graphiques
        let container;  // Conteneur HTML pour Three.js
        let camera;     // Caméra 3D
        let controls;   // Contrôles de la caméra
        let scene;      // Scène Three.js
        let renderer;   // Rendu Three.js
        const clock = new THREE.Clock();  // Horloge pour le calcul du temps

        // Les variables physiques
        const gravityConstant = -9.8;  // Constante de gravité (m/s²)
        let physicsWorld;              // Monde physique Ammo.js
        const softBodies = [];         // Tableau pour stocker les corps mous
        const margin = 0.05;           // Marge pour les collisions
        let softBodyHelpers;           // Outils pour les corps mous

        // Initialisation de la simulation une fois Ammo.js chargé
        Ammo().then(function (AmmoLib) {
            // Stockage de la bibliothèque Ammo
            Ammo = AmmoLib;
            // Lancement de l'initialisation
            init();
        });

        // Fonction principale d'initialisation
        function init() {
            // Initialisation de la partie graphique (Three.js)
            initGraphics();
            // Initialisation de la physique (Ammo.js)
            initPhysics();
            // Création des objets
            createObjects();
        }

        // Initialisation de la partie graphique (Three.js)
        function initGraphics() {
            // Configuration du conteneur HTML
            container = document.getElementById('container');
            
            // Configuration de la caméra
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000);
            camera.position.set(-7, 5, 8);  // Position initiale de la caméra
            
            // Création de la scène
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);  // Fond sombre
            
            // Configuration du renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);  // Qualité d'affichage
            renderer.setSize(window.innerWidth, window.innerHeight);  // Taille de la fenêtre
            renderer.setAnimationLoop(animate);  // Boucle d'animation
            renderer.shadowMap.enabled = true;   // Ombres activées
            container.appendChild(renderer.domElement);  // Ajout au DOM
            
            // Configuration des contrôles de caméra
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 2, 0);  // Point cible de la caméra
            controls.update();  // Mise à jour initiale des contrôles
            
            // Configuration de l'éclairage
            // Lumière ambiante (lumière générale)
            const ambientLight = new THREE.AmbientLight(0xbbbbbb);
            scene.add(ambientLight);
            
            // Lumière directionnelle (lumière principale)
            const light = new THREE.DirectionalLight(0xffffff, 3);
            light.position.set(-10, 10, 5);  // Position de la lumière
            light.castShadow = true;  // Ombres activées
            
            // Configuration des ombres
            const d = 10;  // Distance de la caméra d'ombre
            light.shadow.camera.left = -d;
            light.shadow.camera.right = d;
            light.shadow.camera.top = d;
            light.shadow.camera.bottom = -d;
            light.shadow.camera.near = 2;
            light.shadow.camera.far = 50;
            light.shadow.mapSize.x = 1024;
            light.shadow.mapSize.y = 1024;
            
            scene.add(light);  // Ajout de la lumière à la scène
            
            // Gestion du redimensionnement de la fenêtre
            window.addEventListener('resize', onWindowResize);
        }

        // Initialisation du monde physique avec Ammo.js
        function initPhysics() {
            // Configuration du système de collision
            const collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
            const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
            const broadphase = new Ammo.btDbvtBroadphase();
            
            // Configuration du solveur
            const solver = new Ammo.btSequentialImpulseConstraintSolver();
            const softBodySolver = new Ammo.btDefaultSoftBodySolver();
            
            // Création du monde physique
            physicsWorld = new Ammo.btSoftRigidDynamicsWorld(
                dispatcher,      // Détecteur de collision
                broadphase,     // Méthode de détection large
                solver,         // Solveur principal
                collisionConfiguration,  // Configuration des collisions
                softBodySolver  // Solveur pour les corps mous
            );
            
            // Configuration de la gravité
            physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant, 0));
            physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(0, gravityConstant, 0));

            softBodyHelpers = new Ammo.btSoftBodyHelpers();
        }

        // Création des objets physiques
        function createObjects() {
            // Création du sol
            const pos = new THREE.Vector3(0, -0.5, 0);  // Position du sol
            const quat = new THREE.Quaternion(0, 0, 0, 1);  // Orientation (identité)
            const ground = createParalellepiped(40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0x444444 }));
            ground.receiveShadow = true;  // Le sol reçoit des ombres

            // --- NOTRE CUBE SOUFFLE ---
            // Configuration du cube
            const cubeSize = 3;  // Taille du cube
            const cubeMass = 5;  // Masse du cube
            const cubePressure = 200;  // Pression interne du cube

            // Création de la géométrie du cube
            const boxGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize, 30,  30, 30);
            boxGeometry.translate(0, 5, 0);  // Position initiale (en hauteur)
            
            // Création du corps mou
            createSoftVolume(boxGeometry, cubeMass, cubePressure);
        }
        

        // Création d'un corps mou (soft body)
        function createSoftVolume(bufferGeom, mass, pressure) {
            // Prétraitement de la géométrie pour l'optimisation
            processGeometry(bufferGeom);

            // Création du maillage Three.js
            const volume = new THREE.Mesh(
                bufferGeom, 
                new THREE.MeshPhongMaterial({ color: 0x0088ff })  // Matériau bleu
            );
            volume.castShadow = true;  // Le cube projette des ombres
            volume.receiveShadow = true;  // Le cube reçoit des ombres
            volume.frustumCulled = false;  // Désactive l'optimisation de frustum
            scene.add(volume);  // Ajout à la scène

            // Création du corps mou avec Ammo.js
            const volumeSoftBody = softBodyHelpers.CreateFromTriMesh(
                physicsWorld.getWorldInfo(),  // Informations du monde physique
                bufferGeom.ammoVertices,     // Vertices du maillage
                bufferGeom.ammoIndices,      // Indices des triangles
                bufferGeom.ammoIndices.length / 3,  // Nombre de triangles
                true  // Mode de collision
            );

            // Configuration du corps mou
            const sbConfig = volumeSoftBody.get_m_cfg();
            
            // Paramètres de simulation
            sbConfig.set_viterations(5);  // Nombre d'itérations pour la vitesse
            sbConfig.set_piterations(5);  // Nombre d'itérations pour la position
            sbConfig.set_collisions(0x11); // Type de collisions activées
            
            // Paramètres physiques
            sbConfig.set_kDF(0.2);  // Coefficient de friction
            sbConfig.set_kDP(0.01); // Coefficient d'amortissement
            sbConfig.set_kPR(pressure);  // Pression interne
            
            // Configuration du matériau
            const material = volumeSoftBody.get_m_materials().at(0);
            material.set_m_kLST(0.9);  // Rigidité linéaire
            material.set_m_kAST(0.9);  // Rigidité angulaire

            // Configuration finale du corps mou
            volumeSoftBody.setTotalMass(mass, false);  // Masse totale
            Ammo.castObject(volumeSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(margin);  // Marge de collision
            physicsWorld.addSoftBody(volumeSoftBody, 1, -1);  // Ajout au monde physique
            volume.userData.physicsBody = volumeSoftBody;  // Stockage du corps physique
            volumeSoftBody.setActivationState(4);  // Désactiver la mise en sommeil

            // Ajout du cube à la liste des corps mous
            softBodies.push(volume);
        }

        // Création d'un parallélépipède (solide rigide)
        function createParalellepiped(sx, sy, sz, mass, pos, quat, material) {
            // Création du maillage Three.js
            const threeObject = new THREE.Mesh(
                new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1),  // Géométrie
                material  // Matériau
            );
            
            // Configuration de la forme physique
            const shape = new Ammo.btBoxShape(new Ammo.btVector3(
                sx * 0.5,  // Largeur
                sy * 0.5,  // Hauteur
                sz * 0.5   // Profondeur
            ));
            shape.setMargin(margin);  // Marge de collision
            
            // Création du corps rigide
            createRigidBody(threeObject, shape, mass, pos, quat);
            return threeObject;
        }

        // Création d'un corps rigide (pour le sol)
        function createRigidBody(threeObject, physicsShape, mass, pos, quat) {
            // Configuration de la position et de l'orientation
            threeObject.position.copy(pos);
            threeObject.quaternion.copy(quat);
            
            // Configuration de la transformation
            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));  // Position
            transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));  // Orientation
            const motionState = new Ammo.btDefaultMotionState(transform);
            
            // Calcul de l'inertie locale
            const localInertia = new Ammo.btVector3(0, 0, 0);
            physicsShape.calculateLocalInertia(mass, localInertia);
            
            // Création du corps rigide
            const rbInfo = new Ammo.btRigidBodyConstructionInfo(
                mass,          // Masse
                motionState,   // État de mouvement
                physicsShape,  // Forme physique
                localInertia   // Inertie
            );
            const body = new Ammo.btRigidBody(rbInfo);
            
            // Stockage du corps physique
            threeObject.userData.physicsBody = body;
            scene.add(threeObject);  // Ajout à la scène
            physicsWorld.addRigidBody(body);  // Ajout au monde physique
            
            return body;
        }

        // Prétraitement de la géométrie pour l'optimisation
        function processGeometry(bufGeometry) {
            // Création d'une géométrie temporaire avec uniquement les positions
            const posOnlyBufGeometry = new THREE.BufferGeometry();
            posOnlyBufGeometry.setAttribute('position', bufGeometry.getAttribute('position'));
            posOnlyBufGeometry.setIndex(bufGeometry.getIndex());
            
            // Fusion des sommets identiques
            const indexedBufferGeom = BufferGeometryUtils.mergeVertices(posOnlyBufGeometry);
            
            // Mappage des indices
            mapIndices(bufGeometry, indexedBufferGeom);
        }

        // Fonction d'égalité avec tolérance
        function isEqual(x1, y1, z1, x2, y2, z2) {
            // Delta très petit pour la comparaison
            const delta = 0.000001;
            return Math.abs(x2 - x1) < delta &&  // Comparaison des x
                   Math.abs(y2 - y1) < delta &&  // Comparaison des y
                   Math.abs(z2 - z1) < delta;    // Comparaison des z
        }

        // Mappage des indices pour l'optimisation
        function mapIndices(bufGeometry, indexedBufferGeom) {
            // Récupération des données de géométrie
            const vertices = bufGeometry.attributes.position.array;  // Vertices originaux
            const idxVertices = indexedBufferGeom.attributes.position.array;  // Vertices indexés
            const indices = indexedBufferGeom.index.array;  // Indices
            
            // Calcul du nombre de sommets
            const numIdxVertices = idxVertices.length / 3;
            const numVertices = vertices.length / 3;
            
            // Stockage des données pour Ammo.js
            bufGeometry.ammoVertices = idxVertices;
            bufGeometry.ammoIndices = indices;
            bufGeometry.ammoIndexAssociation = [];
            
            // Création des associations de sommets
            for (let i = 0; i < numIdxVertices; i++) {
                const association = [];
                bufGeometry.ammoIndexAssociation.push(association);
                const i3 = i * 3;
                
                // Recherche des sommets équivalents
                for (let j = 0; j < numVertices; j++) {
                    const j3 = j * 3;
                    if (isEqual(
                        idxVertices[i3], idxVertices[i3 + 1], idxVertices[i3 + 2],
                        vertices[j3], vertices[j3 + 1], vertices[j3 + 2]
                    )) {
                        association.push(j3);
                    }
                }
            }
        }

        // Gestion du redimensionnement de la fenêtre
        function onWindowResize() {
            // Mise à jour du ratio d'aspect de la caméra
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();  // Recalcule la matrice de projection
            
            // Mise à jour de la taille du renderer
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Boucle principale d'animation
        function animate() {
            // Récupération du temps écoulé depuis le dernier frame
            const deltaTime = clock.getDelta();
            
            // Mise à jour de la physique
            updatePhysics(deltaTime);
            
            // Rendu de la scène
            renderer.render(scene, camera);
        }

        // Mise à jour de la physique
        function updatePhysics(deltaTime) {
            // Simulation physique
            physicsWorld.stepSimulation(deltaTime, 10);  // 10 sous-pas de simulation
            
            // Mise à jour de tous les corps mous
            for (let i = 0, il = softBodies.length; i < il; i++) {
                const volume = softBodies[i];
                const geometry = volume.geometry;
                const softBody = volume.userData.physicsBody;
                
                // Récupération des données du corps mou
                const volumePositions = geometry.attributes.position.array;
                const volumeNormals = geometry.attributes.normal.array;
                const association = geometry.ammoIndexAssociation;
                const numVerts = association.length;
                const nodes = softBody.get_m_nodes();
                
                // Mise à jour de chaque sommet
                for (let j = 0; j < numVerts; j++) {
                    const node = nodes.at(j);
                    const nodePos = node.get_m_x();  // Position
                    const x = nodePos.x();
                    const y = nodePos.y();
                    const z = nodePos.z();
                    
                    const nodeNormal = node.get_m_n();  // Normale
                    const nx = nodeNormal.x();
                    const ny = nodeNormal.y();
                    const nz = nodeNormal.z();
                    
                    const assocVertex = association[j];
                    
                    // Mise à jour des positions et normales
                    for (let k = 0, kl = assocVertex.length; k < kl; k++) {
                        let indexVertex = assocVertex[k];
                        volumePositions[indexVertex] = x;
                        volumeNormals[indexVertex] = nx;
                        indexVertex++;
                        volumePositions[indexVertex] = y;
                        volumeNormals[indexVertex] = ny;
                        indexVertex++;
                        volumePositions[indexVertex] = z;
                        volumeNormals[indexVertex] = nz;
                    }
                }
                
                // Marquage des attributs comme needing update
                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.normal.needsUpdate = true;
            }
        }
    </script>
</body>
</html>